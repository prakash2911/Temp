const fs = require('fs');
const readline = require('readline');

class LogParser {
    /**
     * Parse log file and segregate requests and responses
     * @param {string} inputLogFile - Path to the input log file
     * @returns {Promise<{requests: Map<string, Array>, responses: Map<string, Array>}>}
     */
    static async parseLogFile(inputLogFile) {
        // Maps to store requests and responses
        const requests = new Map();
        const responses = new Map();

        // Regex patterns to extract relevant information
        const requestPattern = /^(.*?)\s*REST CALL Request:\s*(.+)$/;
        const responsePattern = /^(.*?)\s*HTTP Response:\s*(.+)$/;

        // Create readline interface
        const fileStream = fs.createReadStream(inputLogFile);
        const rl = readline.createInterface({
            input: fileStream,
            crlfDelay: Infinity
        });

        // Process each line
        for await (const line of rl) {
            // Check for request lines
            const requestMatch = line.match(requestPattern);
            if (requestMatch) {
                const timestamp = requestMatch[1].trim();
                const requestData = requestMatch[2].trim();

                try {
                    // Parse request data as JSON
                    const parsedRequest = JSON.parse(requestData);

                    // Extract universal request ID and page number
                    const universalRequestId = parsedRequest['universal-request-id'];
                    const page = parsedRequest.page || 0;

                    if (universalRequestId) {
                        if (!requests.has(universalRequestId)) {
                            requests.set(universalRequestId, []);
                        }
                        requests.get(universalRequestId).push({
                            timestamp,
                            page,
                            data: parsedRequest
                        });
                    }
                } catch (error) {
                    console.warn(`Warning: Could not parse request JSON: ${requestData}`, error);
                }
            }

            // Check for response lines
            const responseMatch = line.match(responsePattern);
            if (responseMatch) {
                const timestamp = responseMatch[1].trim();
                const responseData = responseMatch[2].trim();

                try {
                    // Parse response data as JSON
                    const parsedResponse = JSON.parse(responseData);

                    // Extract universal request ID and page number
                    const universalRequestId = parsedResponse['universal-request-id'];
                    const page = parsedResponse.page || 0;

                    if (universalRequestId) {
                        if (!responses.has(universalRequestId)) {
                            responses.set(universalRequestId, []);
                        }
                        responses.get(universalRequestId).push({
                            timestamp,
                            page,
                            data: parsedResponse
                        });
                    }
                } catch (error) {
                    console.warn(`Warning: Could not parse response JSON: ${responseData}`, error);
                }
            }
        }

        return { requests, responses };
    }

    /**
     * Write segregated logs to output files
     * @param {Map<string, Array>} requests - Parsed requests
     * @param {Map<string, Array>} responses - Parsed responses
     * @param {Object} options - Configuration options
     */
    static writeSegregatedLogs(
        requests, 
        responses, 
        options = {
            requestOutputFile: 'rest_call_requests.log',
            responseOutputFile: 'http_responses.log'
        }
    ) {
        // Helper function to sort by page
        const sortByPage = (items) => {
            return items.sort((a, b) => (a.page || 0) - (b.page || 0));
        };

        // Write requests
        const requestWriteStream = fs.createWriteStream(options.requestOutputFile);
        for (const [reqId, reqList] of requests.entries()) {
            const sortedRequests = sortByPage(reqList);
            
            sortedRequests.forEach(req => {
                requestWriteStream.write(`Universal Request ID: ${reqId}\n`);
                requestWriteStream.write(`Timestamp: ${req.timestamp}\n`);
                requestWriteStream.write(`Page: ${req.page}\n`);
                requestWriteStream.write(`Request Data: ${JSON.stringify(req.data, null, 2)}\n`);
                requestWriteStream.write("\n---\n\n");
            });
        }
        requestWriteStream.end();

        // Write responses
        const responseWriteStream = fs.createWriteStream(options.responseOutputFile);
        for (const [respId, respList] of responses.entries()) {
            const sortedResponses = sortByPage(respList);
            
            sortedResponses.forEach(resp => {
                responseWriteStream.write(`Universal Request ID: ${respId}\n`);
                responseWriteStream.write(`Timestamp: ${resp.timestamp}\n`);
                responseWriteStream.write(`Page: ${resp.page}\n`);
                responseWriteStream.write(`Response Data: ${JSON.stringify(resp.data, null, 2)}\n`);
                responseWriteStream.write("\n---\n\n");
            });
        }
        responseWriteStream.end();
    }

    /**
     * Main method to parse and write log files
     * @param {string} inputLogFile - Path to the input log file
     * @param {Object} options - Configuration options
     */
    static async processLogFile(
        inputLogFile, 
        options = {
            requestOutputFile: 'rest_call_requests.log',
            responseOutputFile: 'http_responses.log'
        }
    ) {
        try {
            // Parse the log file
            const { requests, responses } = await this.parseLogFile(inputLogFile);

            // Write segregated logs
            this.writeSegregatedLogs(requests, responses, options);

            console.log('Log file parsing completed successfully.');
        } catch (error) {
            console.error('Error processing log file:', error);
        }
    }
}

// Example usage
// LogParser.processLogFile('input.log');

module.exports = LogParser;