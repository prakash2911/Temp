import java.lang.reflect.Field;
import java.lang.reflect.ParameterizedType;
import java.util.ArrayList;
import java.util.List;
import java.util.Random;

public class MockDataGenerator {

    private static final Random random = new Random();

    public static <T> T generateMockData(Class<T> clazz) {
        try {
            T instance = clazz.getDeclaredConstructor().newInstance();

            for (Field field : clazz.getDeclaredFields()) {
                field.setAccessible(true);

                Class<?> type = field.getType();

                if (type == String.class) {
                    field.set(instance, "mock_" + field.getName());
                } else if (type == int.class || type == Integer.class) {
                    field.set(instance, random.nextInt(100));
                } else if (type == long.class || type == Long.class) {
                    field.set(instance, random.nextLong());
                } else if (type == boolean.class || type == Boolean.class) {
                    field.set(instance, random.nextBoolean());
                } else if (type == double.class || type == Double.class) {
                    field.set(instance, random.nextDouble());
                } else if (List.class.isAssignableFrom(type)) {
                    // Handle lists by creating a list of mock elements
                    ParameterizedType listType = (ParameterizedType) field.getGenericType();
                    Class<?> listElementType = (Class<?>) listType.getActualTypeArguments()[0];

                    List<Object> mockList = new ArrayList<>();
                    for (int i = 0; i < 3; i++) { // Arbitrary number of list elements
                        if (listElementType == String.class) {
                            mockList.add("mock_" + field.getName() + "_" + i);
                        } else {
                            mockList.add(generateMockData(listElementType));
                        }
                    }
                    field.set(instance, mockList);
                } else if (!type.isPrimitive() && !type.isEnum() && !type.isArray() && !type.isAssignableFrom(String.class)) {
                    // If the field is an object, recursively generate mock data for it
                    Object nestedObject = generateMockData(type);
                    field.set(instance, nestedObject);
                }
                // Add more type cases as needed
            }

            return instance;
        } catch (Exception e) {
            throw new RuntimeException("Error generating mock data", e);
        }
    }
}
