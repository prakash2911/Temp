import React, { useState, useMemo } from "react";
import { Table, Select, Input, Button, Row, Col } from "antd";
import { useQuery } from "react-query";
import axios from "axios";

const { Option } = Select;

const fetchTrades = async ({ queryKey }) => {
  const [, serviceName, sourceIds, page, size, filters] = queryKey;
  if (!serviceName || sourceIds.length === 0) return { header: [], data: [], total: 0 };

  const { data } = await axios.get("http://localhost:8080/api/trades", {
    params: { serviceName, sourceIds, page, size, filters: JSON.stringify(filters) },
  });
  return data;
};

const TradeTable = () => {
  const [serviceName, setServiceName] = useState(null);
  const [sourceIds, setSourceIds] = useState([]);
  const [page, setPage] = useState(0);
  const pageSize = 10;
  const [searchText, setSearchText] = useState("");
  const [sortColumn, setSortColumn] = useState(null);
  const [sortOrder, setSortOrder] = useState(null);
  const [filters, setFilters] = useState([]);
  const [availableColumns, setAvailableColumns] = useState([]);

  const { data, isLoading } = useQuery(
    ["trades", serviceName, sourceIds, page, pageSize, filters],
    fetchTrades,
    { enabled: !!serviceName && sourceIds.length > 0 }
  );

  // Set available columns dynamically
  useMemo(() => {
    if (data?.header) {
      setAvailableColumns(data.header.map((h) => h.columnName));
    }
  }, [data]);

  // Add a new filter
  const addFilter = () => {
    setFilters([...filters, { column: null, value: "" }]);
  };

  // Update a filter value
  const updateFilter = (index, key, value) => {
    const newFilters = [...filters];
    newFilters[index][key] = value;
    setFilters(newFilters);
  };

  // Handle sorting logic
  const sortedData = useMemo(() => {
    if (!sortColumn || !data?.data) return data?.data || [];

    return [...data.data].sort((a, b) => {
      const aValue = a[sortColumn];
      const bValue = b[sortColumn];

      if (typeof aValue === "number" && typeof bValue === "number") {
        return sortOrder === "ascend" ? aValue - bValue : bValue - aValue;
      }

      return sortOrder === "ascend"
        ? String(aValue).localeCompare(String(bValue))
        : String(bValue).localeCompare(String(aValue));
    });
  }, [data?.data, sortColumn, sortOrder]);

  // Handle search filter logic
  const filteredData = useMemo(() => {
    if (!searchText) return sortedData;

    return sortedData.filter((row) =>
      Object.values(row).some((value) =>
        String(value).toLowerCase().includes(searchText.toLowerCase())
      )
    );
  }, [sortedData, searchText]);

  // Generate table columns dynamically with sorting
  const columns = data?.header.map((header) => ({
    title: header.columnName.toUpperCase(),
    dataIndex: header.columnName,
    key: header.columnName,
    sorter: true,
    sortOrder: sortColumn === header.columnName ? sortOrder : null,
    onHeaderCell: () => ({
      onClick: () => {
        if (sortColumn === header.columnName) {
          setSortOrder(sortOrder === "ascend" ? "descend" : "ascend");
        } else {
          setSortColumn(header.columnName);
          setSortOrder("ascend");
        }
      },
    }),
  }));

  return (
    <div style={{ padding: "20px" }}>
      <Select
        placeholder="Select Service"
        style={{ width: 200, marginRight: 10 }}
        onChange={setServiceName}
      >
        <Option value="Service1">Service1</Option>
        <Option value="Service2">Service2</Option>
      </Select>

      <Input
        placeholder="Enter Source IDs (comma-separated)"
        style={{ width: 300, marginRight: 10 }}
        onChange={(e) => setSourceIds(e.target.value.split(","))}
      />

      <Button type="primary" onClick={() => setPage(0)}>
        Search
      </Button>

      <Button type="dashed" style={{ marginLeft: 10 }} onClick={addFilter}>
        + Add Filter
      </Button>

      {filters.map((filter, index) => (
        <Row key={index} style={{ marginTop: 10 }}>
          <Col>
            <Select
              placeholder="Select Column"
              style={{ width: 200, marginRight: 10 }}
              onChange={(value) => updateFilter(index, "column", value)}
            >
              {availableColumns.map((col) => (
                <Option key={col} value={col}>
                  {col}
                </Option>
              ))}
            </Select>
          </Col>

          <Col>
            <Input
              placeholder="Enter Filter Value (comma-separated)"
              style={{ width: 300, marginRight: 10 }}
              onChange={(e) => updateFilter(index, "value", e.target.value)}
            />
          </Col>
        </Row>
      ))}

      <Table
        columns={columns}
        dataSource={filteredData}
        loading={isLoading}
        rowKey="id"
        pagination={{
          current: page + 1,
          pageSize,
          total: data?.total,
          onChange: (p) => setPage(p - 1),
        }}
        style={{ marginTop: 20 }}
      />
    </div>
  );
};

export default TradeTable;



@GetMapping
public Map<String, Object> getTrades(
    @RequestParam String serviceName, 
    @RequestParam List<String> sourceIds,
    @RequestParam int page,
    @RequestParam int size,
    @RequestParam(required = false) String filters
) {
    int offset = page * size;
    int limit = size;
    
    // Base Query
    String sql = "SELECT * FROM tradeview WHERE servicename = ? " +
                 "AND source_id IN (" + String.join(",", Collections.nCopies(sourceIds.size(), "?")) + ") ";

    List<Object> params = new ArrayList<>();
    params.add(serviceName);
    params.addAll(sourceIds);

    // Adding dynamic filters
    if (filters != null && !filters.isEmpty()) {
        List<Map<String, String>> filterList = new Gson().fromJson(filters, new TypeToken<List<Map<String, String>>>() {}.getType());
        for (Map<String, String> filter : filterList) {
            sql += " AND " + filter.get("column") + " IN (" +
                   String.join(",", Collections.nCopies(filter.get("value").split(",").length, "?")) + ") ";
            params.addAll(Arrays.asList(filter.get("value").split(",")));
        }
    }

    sql += " ORDER BY trade_date DESC OFFSET ? ROWS FETCH NEXT ? ROWS ONLY";
    params.add(offset);
    params.add(limit);

    List<Map<String, Object>> result = jdbcTemplate.queryForList(sql, params.toArray());

    // Response
    Map<String, Object> response = new HashMap<>();
    response.put("header", result.isEmpty() ? Collections.emptyList() : result.get(0).keySet());
    response.put("data", result);
    response.put("total", result.size());
    response.put("page", page);
    response.put("size", size);

    return response;
}