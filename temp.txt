const fs = require('fs');
const readline = require('readline');

class HTTPResponseExtractor {
    constructor(logFilePath) {
        this.logFilePath = logFilePath;
        this.responses = [];
    }

    /**
     * Extract HTTP responses from the log file
     * @param {Object} options - Configuration options for extraction
     * @param {string} [options.responseStartPattern=/HTTP\/\d\.\d \d{3}/] - Regex to detect response start
     * @param {string} [options.responseEndPattern=null] - Optional regex to detect response end
     * @returns {Promise<Array>} Extracted responses
     */
    async extractResponses(options = {}) {
        const {
            responseStartPattern = /HTTP\/\d\.\d \d{3}/,
            responseEndPattern = null
        } = options;

        this.responses = [];
        let currentResponse = null;

        const fileStream = fs.createReadStream(this.logFilePath, { encoding: 'utf8' });
        const rl = readline.createInterface({
            input: fileStream,
            crlfDelay: Infinity
        });

        return new Promise((resolve, reject) => {
            rl.on('line', (line) => {
                // Check if line starts a new response
                if (responseStartPattern.test(line)) {
                    // Save previous response if exists
                    if (currentResponse) {
                        this.responses.push(currentResponse);
                    }

                    // Start a new response
                    currentResponse = {
                        rawText: line,
                        headers: {},
                        body: '',
                        metadata: {
                            startTimestamp: new Date()
                        }
                    };
                }
                
                // If tracking a response, continue building it
                if (currentResponse) {
                    currentResponse.rawText += '\n' + line;

                    // Parse headers
                    if (line.includes(': ')) {
                        try {
                            const [key, value] = line.trim().split(': ');
                            currentResponse.headers[key] = value;
                        } catch (err) {
                            // Ignore parsing errors
                        }
                    }

                    // Optional end of response detection
                    if (responseEndPattern && responseEndPattern.test(line)) {
                        this.responses.push(currentResponse);
                        currentResponse = null;
                    }
                }
            });

            rl.on('close', () => {
                // Add last response if exists
                if (currentResponse) {
                    this.responses.push(currentResponse);
                }
                resolve(this.responses);
            });

            rl.on('error', (err) => {
                reject(err);
            });
        });
    }

    /**
     * Chunk the extracted responses
     * @param {Object} options - Chunking configuration
     * @param {number} [options.chunkSize=1024] - Size of each chunk in bytes
     * @param {number} [options.overlap=0] - Number of bytes to overlap between chunks
     * @returns {Array} Chunked responses
     */
    chunkResponses(options = {}) {
        const {
            chunkSize = 1024,
            overlap = 0
        } = options;

        if (this.responses.length === 0) {
            throw new Error('No responses extracted. Run extractResponses() first.');
        }

        const chunkedResponses = [];

        this.responses.forEach(response => {
            const rawText = response.rawText;

            // Create chunks with optional overlap
            for (let i = 0; i < rawText.length; i += chunkSize - overlap) {
                chunkedResponses.push({
                    text: rawText.slice(i, i + chunkSize),
                    startIndex: i,
                    endIndex: Math.min(i + chunkSize, rawText.length),
                    responseMetadata: response.metadata
                });
            }
        });

        return chunkedResponses;
    }

    /**
     * Save extracted responses to a file
     * @param {string} outputPath - Path to save extracted responses
     * @param {string} [format='json'] - Output format (json or txt)
     */
    async saveResponses(outputPath, format = 'json') {
        if (this.responses.length === 0) {
            throw new Error('No responses to save. Run extractResponses() first.');
        }

        const content = format === 'json' 
            ? JSON.stringify(this.responses, null, 2)
            : this.responses.map(r => r.rawText).join('\n\n---RESPONSE SEPARATOR---\n\n');

        await fs.promises.writeFile(outputPath, content);
    }
}

// Example usage
async function processLogFile() {
    try {
        const extractor = new HTTPResponseExtractor('path/to/your/logfile.log');
        
        // Extract responses
        await extractor.extractResponses({
            responseStartPattern: /HTTP\/\d\.\d \d{3}/,
            responseEndPattern: null
        });

        // Chunk responses
        const chunks = extractor.chunkResponses({
            chunkSize: 1024,
            overlap: 100
        });

        // Optionally save responses
        await extractor.saveResponses('extracted_responses.json');

        return chunks;
    } catch (error) {
        console.error('Error processing log file:', error);
    }
}

module.exports = {
    HTTPResponseExtractor,
    processLogFile
};